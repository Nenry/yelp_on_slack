{"version":3,"sources":["../src/adapter.js"],"names":["debug","formatMatchingConstraints","matchingConstraints","ret","TypeError","callbackId","Object","assign","validateConstraints","validateActionConstraints","actionConstraints","type","validateOptionsConstraints","optionsConstraints","within","SlackMessageAdapter","verificationToken","syncResponseTimeout","lateResponseFallbackEnabled","callbacks","axios","create","headers","path","Promise","resolve","then","all","express","bodyParser","app","use","urlencoded","extended","post","expressMiddleware","createServer","port","reject","server","on","listen","close","error","Error","callback","handlerType","message","registerCallback","payload","matchCallback","undefined","callbackFn","respond","response_url","callbackResult","call","status","content","catch","code","PROMISE_TIMEOUT","callbackError","constraints","push","find","callback_id","test","actions","submission","action","selected_options","unfurl","is_app_unfurl"],"mappings":"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","file":"adapter.js","sourcesContent":["/**\n * @module adapter\n */\n\nimport http from 'http';\nimport axios from 'axios';\nimport isString from 'lodash.isstring';\nimport isPlainObject from 'lodash.isplainobject';\nimport isRegExp from 'lodash.isregexp';\nimport isFunction from 'lodash.isfunction';\nimport debugFactory from 'debug';\nimport { createExpressMiddleware } from './express-middleware';\nimport { packageIdentifier, promiseTimeout, errorCodes as utilErrorCodes } from './util';\n\nconst debug = debugFactory('@slack/interactive-messages:adapter');\n\n/**\n * Transforms various forms of matching constraints to a single standard object shape\n * @param {string|RegExp|Object} matchingConstraints - the various forms of matching constraints\n * accepted\n * @returns {Object} - an object where each matching constraint is a property\n * @private\n */\nfunction formatMatchingConstraints(matchingConstraints) {\n  let ret = {};\n  if (typeof matchingConstraints === 'undefined' || matchingConstraints === null) {\n    throw new TypeError('Callback ID cannot be undefined or null');\n  }\n  if (!isPlainObject(matchingConstraints)) {\n    ret.callbackId = matchingConstraints;\n  } else {\n    ret = Object.assign({}, matchingConstraints);\n  }\n  return ret;\n}\n\n/**\n * Validates general properties of a matching constraints object\n * @param {Object} matchingConstraints - object describing the constraints on a callback\n * @returns {Error|false} - a false value represents successful validation, otherwise an error to\n * describe why validation failed.\n * @private\n */\nfunction validateConstraints(matchingConstraints) {\n  if (matchingConstraints.callbackId &&\n      !(isString(matchingConstraints.callbackId) || isRegExp(matchingConstraints.callbackId))) {\n    return new TypeError('Callback ID must be a string or RegExp');\n  }\n\n  return false;\n}\n\n/**\n * Validates properties of a matching constraints object specific to registering an action\n * @param {Object} matchingConstraints - object describing the constraints on a callback\n * @returns {Error|false} - a false value represents successful validation, otherwise an error to\n * describe why validation failed.\n * @private\n */\nfunction validateActionConstraints(actionConstraints) {\n  if (actionConstraints.type &&\n    !(actionConstraints.type === 'select' || actionConstraints.type === 'button' ||\n    actionConstraints.type === 'dialog_submission' || actionConstraints.type === 'message_action')\n  ) {\n    return new TypeError('Type must be \\'select\\', \\'button\\', \\'dialog_submission\\', or \\'message_action\\'');\n  }\n\n  // We don't need to validate unfurl, we'll just cooerce it to a boolean\n  return false;\n}\n\n/**\n * Validates properties of a matching constraints object specific to registering an options request\n * @param {Object} matchingConstraints - object describing the constraints on a callback\n * @returns {Error|false} - a false value represents successful validation, otherwise an error to\n * describe why validation failed.\n * @private\n */\nfunction validateOptionsConstraints(optionsConstraints) {\n  if (optionsConstraints.within &&\n    !(optionsConstraints.within === 'interactive_message' ||\n      optionsConstraints.within === 'dialog')\n  ) {\n    return new TypeError('Within must be \\'interactive_message\\' or \\'dialog\\'');\n  }\n\n  // We don't need to validate unfurl, we'll just cooerce it to a boolean\n  return false;\n}\n\n/**\n * An adapter for Slack's interactive message components such as buttons, menus, and dialogs.\n * @typicalname slackInteractions\n */\nclass SlackMessageAdapter {\n  /**\n   * Create a message adapter.\n   *\n   * @param {string} verificationToken - Slack app verification token used to authenticate request\n   * @param {Object} [options]\n   * @param {number} [options.syncResponseTimeout=2500] - number of milliseconds to wait before\n   * flushing a syncrhonous response to an incoming request and falling back to an asynchronous\n   * response.\n   * @param {boolean} [options.lateResponseFallbackEnabled=true] - whether or not promises that\n   * resolve after the syncResponseTimeout can fallback to a request for the response_url. this only\n   * works in cases where the semantic meaning of the response and the response_url are the same.\n   */\n  constructor(verificationToken, {\n    syncResponseTimeout = 2500,\n    lateResponseFallbackEnabled = true,\n  } = {}) {\n    if (!isString(verificationToken)) {\n      throw new TypeError('SlackMessageAdapter needs a verification token');\n    }\n\n    if (syncResponseTimeout > 3000 || syncResponseTimeout < 1) {\n      throw new TypeError('syncResponseTimeout must be between 1 and 3000');\n    }\n\n    this.verificationToken = verificationToken;\n    this.syncResponseTimeout = syncResponseTimeout;\n    this.lateResponseFallbackEnabled = lateResponseFallbackEnabled;\n    this.callbacks = [];\n    this.axios = axios.create({\n      headers: {\n        'User-Agent': packageIdentifier(),\n      },\n    });\n\n    debug('instantiated');\n  }\n\n  /* Interface for using the built-in server */\n\n  /**\n   * Create a server that dispatches Slack's interactive message actions and menu requests to this\n   * message adapter instance. Use this method if your application will handle starting the server.\n   *\n   * @param {string} [path=/slack/actions] - The path portion of the URL where the server will\n   * listen for requests from Slack's interactive messages.\n   * @returns {Promise<NodeHttpServer>} - A promise that resolves to an instance of http.Server and\n   * will dispatch interactive message actions and options requests to this message adapter\n   * instance. https://nodejs.org/dist/latest/docs/api/http.html#http_class_http_server\n   */\n  createServer(path = '/slack/actions') {\n    // TODO: more options (like https)\n    return Promise.resolve().then(() => Promise.all([\n      import('express'),\n      import('body-parser'),\n    ]))\n      .then(([express, bodyParser]) => {\n        const app = express();\n        app.use(bodyParser.urlencoded({ extended: false }));\n        app.post(path, this.expressMiddleware());\n\n        debug('server created - path: %s', path);\n\n        return http.createServer(app);\n      });\n  }\n\n  /**\n   * Start a built-in server that dispatches Slack's interactive message actions and menu requests\n   * to this message adapter interface.\n   *\n   * @param {number} port\n   * @returns {Promise<void>} - A promise that resolves once the server is ready\n   */\n  start(port) {\n    return this.createServer()\n      .then(server => new Promise((resolve, reject) => {\n        this.server = server;\n        server.on('error', reject);\n        server.listen(port, () => resolve(server));\n        debug('server started - port: %s', port);\n      }));\n  }\n\n  /**\n   * Stop the previously started built-in server.\n   *\n   * @returns {Promise<void>} - A promise that resolves once the server is cleaned up.\n   */\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((error) => {\n          delete this.server;\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      } else {\n        reject(new Error('SlackMessageAdapter cannot stop when it did not start a server'));\n      }\n    });\n  }\n\n  /* Interface for bringing your own server */\n\n  /**\n   * Create a middleware function that can be used to integrate with the `express` web framework\n   * in order for incoming requests to be dispatched to this message adapter instance.\n   *\n   * @returns {ExpressMiddlewareFunc} - A middleware function http://expressjs.com/en/guide/using-middleware.html\n   */\n  expressMiddleware() {\n    return createExpressMiddleware(this);\n  }\n\n  /* Interface for adding handlers */\n\n  /* eslint-disable max-len */\n  /**\n   * Add a handler for an interactive message action.\n   *\n   * Usually there's no need to be concerned with _how_ a message is sent to Slack, but the\n   * following table describes it fully.\n   *\n   * **Action**|**Return `object`**|**Return `Promise<object>`**|**Return `undefined`**|**Call `respond(message)`**|**Notes**\n   * :-----:|:-----:|:-----:|:-----:|:-----:|:-----:\n   * **Button Press**| Message in response | When resolved before `syncResposeTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` | Create a new message instead of replacing using `replace_original: false`\n   * **Menu Selection**| Message in response | When resolved before `syncResposeTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` | Create a new message instead of replacing using `replace_original: false`\n   * **Message Action** | Message in response | When resolved before `syncResposeTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` |\n   * **Dialog Submission**| Error list in response | Error list in response | Empty response | Message in request to `response_url` | Returning a Promise that takes longer than 3 seconds to resolve can result in the user seeing an error. Warning logged if a promise isn't completed before `syncResponseTimeout`.\n   *\n   * @param {Object|string|RegExp} matchingConstraints - the callback ID (as a string or RegExp) or\n   * an object describing the constraints to match actions for the handler.\n   * @param {string|RegExp} [matchingConstraints.callbackId] - a string or RegExp to match against\n   * the `callback_id`\n   * @param {string} [matchingConstraints.type] - when `select` only for menu selections, when\n   * `button` only for buttton presses, or when `dialog_submission` only for dialog submissions\n   * @param {boolean} [matchingConstraints.unfurl] - when `true` only match actions from an unfurl\n   * @param {module:adapter~SlackMessageAdapter~ActionHandler} callback - the function to run when\n   * an action is matched\n   * @returns {module:adapter~SlackMessageAdapter} - this instance (for chaining)\n   */\n  action(matchingConstraints, callback) {\n    /* eslint-enable max-len */\n    const actionConstraints = formatMatchingConstraints(matchingConstraints);\n    actionConstraints.handlerType = 'action';\n\n    const error = validateConstraints(actionConstraints) ||\n      validateActionConstraints(actionConstraints);\n    if (error) {\n      debug('action could not be registered: %s', error.message);\n      throw error;\n    }\n\n    return this.registerCallback(actionConstraints, callback);\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Add a handler for an options request\n   *\n   * Usually there's no need to be concerned with _how_ a message is sent to Slack, but the\n   * following table describes it fully\n   *\n   * &nbsp;|**Return `options`**|**Return `Promise<options>`**|**Return `undefined`**|**Notes**\n   * :-----:|:-----:|:-----:|:-----:|:-----:\n   * **Options Request**| Options in response | Options in response | Empty response | Returning a Promise that takes longer than 3 seconds to resolve can result in the user seeing an error. If the request is from within a dialog, the `text` field is called `label`.\n   *\n   * @param {object} matchingConstraints - the callback ID (as a string or RegExp) or\n   * an object describing the constraints to select options requests for the handler.\n   * @param {string|RegExp} [matchingConstraints.callbackId] - a string or RegExxp to match against\n   * the `callback_id`\n   * @param {string} [matchingConstraints.within] - when `interactive_message` only for menus in\n   * an interactive message, or when `dialog` only for menus in a dialog\n   * @param {module:adapter~SlackMessageAdapter~OptionsHandler} callback - the function to run when\n   * an options request is matched\n   * @returns {module:adapter~SlackMessageAdapter} - this instance (for chaining)\n   */\n  options(matchingConstraints, callback) {\n    /* eslint-enable max-len */\n    const optionsConstraints = formatMatchingConstraints(matchingConstraints);\n    optionsConstraints.handlerType = 'options';\n\n    const error = validateConstraints(optionsConstraints) ||\n      validateOptionsConstraints(optionsConstraints);\n    if (error) {\n      debug('options could not be registered: %s', error.message);\n      throw error;\n    }\n\n    return this.registerCallback(optionsConstraints, callback);\n  }\n\n  /* Interface for HTTP servers (like express middleware) */\n\n  /**\n   * Dispatches the contents of an HTTP request to the registered handlers.\n   *\n   * @param {object} payload\n   * @returns {Promise<{ status: number, content: object|string|undefined }>|undefined} - A promise\n   * of the response information (an object with status and content that is a JSON serializable\n   * object or a string or undefined) for the request. An undefined return value indicates that the\n   * request was not matched.\n   * @private\n   */\n  dispatch(payload) {\n    const callback = this.matchCallback(payload);\n    if (!callback) {\n      debug('dispatch could not find a handler');\n      return undefined;\n    }\n    debug('dispatching to handler');\n    const [, callbackFn] = callback;\n\n    // when a response_url is present,`respond()` function created to to send a message using it\n    let respond;\n    if (payload.response_url) {\n      respond = (message) => {\n        if (typeof message.then === 'function') {\n          throw new TypeError('Cannot use a Promise as the parameter for respond()');\n        }\n        debug('sending async response');\n        return this.axios.post(payload.response_url, message);\n      };\n    }\n\n    let callbackResult;\n    try {\n      callbackResult = callbackFn.call(this, payload, respond);\n    } catch (error) {\n      debug('callback error: %o', error);\n      return Promise.resolve({ status: 500 });\n    }\n\n    if (callbackResult) {\n      return promiseTimeout(this.syncResponseTimeout, callbackResult)\n        .then(content => ({ status: 200, content }))\n        .catch((error) => {\n          if (error.code === utilErrorCodes.PROMISE_TIMEOUT) {\n            // warn and continue for promises that cannot be saved with a later async response.\n            // this includes dialog submissions because the response_url doesn't have the same\n            // semantics as the response, any request that doesn't contain a response_url, and\n            // if this has been explicitly disabled in the configuration.\n            if (!this.lateResponseFallbackEnabled || !respond || payload.type === 'dialog_submission') {\n              debug('WARNING: The response Promise did not resolve under the timeout.');\n              return callbackResult\n                .then(content => ({ status: 200, content }))\n                .catch(() => ({ status: 500 }));\n            }\n\n            // save a late promise by sending an empty body in the response, and then use the\n            // response_url to send the eventually resolved value\n            callbackResult.then(respond).catch((callbackError) => {\n              // when the promise is late and fails, we cannot do anything but log it\n              debug('ERROR: Promise was late and failed. Use `.catch()` to handle errors.');\n              throw callbackError;\n            });\n            return { status: 200 };\n          }\n\n          return { status: 500 };\n        });\n    }\n\n    // The following result value represents:\n    // * \"no replacement\" for message actions\n    // * \"submission is valid\" for dialog submissions\n    // * \"no suggestions\" for menu options TODO: check that this is true\n    return Promise.resolve({ status: 200 });\n  }\n\n  /**\n   * @private\n   */\n  registerCallback(constraints, callback) {\n    // Validation\n    if (!isFunction(callback)) {\n      debug('did not register callback because its not a function');\n      throw new TypeError('callback must be a function');\n    }\n\n    this.callbacks.push([constraints, callback]);\n\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  matchCallback(payload) {\n    return this.callbacks.find(([constraints]) => {\n      // if the callback ID constraint is specified, only continue if it matches\n      if (constraints.callbackId) {\n        if (isString(constraints.callbackId) && payload.callback_id !== constraints.callbackId) {\n          return false;\n        }\n        if (isRegExp(constraints.callbackId) && !constraints.callbackId.test(payload.callback_id)) {\n          return false;\n        }\n      }\n\n      // if the action constraint is specified, only continue if it matches\n      if (constraints.handlerType === 'action') {\n        // a payload that represents an action either has actions or submission defined\n        if (!(payload.actions || payload.submission)) {\n          return false;\n        }\n\n        // dialog submissions don't have an action defined, so an empty action is substituted for\n        // the purpose of callback matching\n        const action = payload.actions ? payload.actions[0] : {};\n\n        // button and message actions have a type defined inside the action, dialog submission\n        // actions have a type defined at the top level, and select actions don't have a type\n        // defined, but type can be inferred by checking if a `selected_options` property exists in\n        // the action.\n        const type = action.type || payload.type || (action.selected_options && 'select');\n        if (!type) {\n          debug('no type found in dispatched action');\n        }\n        // if the type constraint is specified, only continue if it matches\n        if (constraints.type && constraints.type !== type) {\n          return false;\n        }\n\n        // if the unfurl constraint is specified, only continue if it matches\n        if ('unfurl' in constraints &&\n          (\n            (constraints.unfurl && !payload.is_app_unfurl) ||\n            (!constraints.unfurl && payload.is_app_unfurl)\n          )\n        ) {\n          return false;\n        }\n      }\n\n      if (constraints.handlerType === 'options') {\n        // a payload that represents an options request always has a name defined at the top level\n        if (!('name' in payload)) {\n          return false;\n        }\n\n        // an options request always has a type at the top level which can be one of two values\n        // that need to be mapped into the values for the `within` constraint:\n        // * type:interactive_message => within:interactive_message\n        // * type:dialog_suggestion => within:dialog\n        if (constraints.within) {\n          if (constraints.within === 'interactive_message' && payload.type !== 'interactive_message') {\n            return false;\n          }\n          if (constraints.within === 'dialog' && payload.type !== 'dialog_suggestion') {\n            return false;\n          }\n        }\n      }\n\n      // if there's no reason to eliminate this callback, then its a match!\n      return true;\n    });\n  }\n}\n\n/**\n * @alias module:adapter\n */\nexport default SlackMessageAdapter;\n\n/**\n * @external ExpressMiddlewareFunc\n * @see http://expressjs.com/en/guide/using-middleware.html\n */\n\n/**\n * @external NodeHttpServer\n * @see https://nodejs.org/dist/latest/docs/api/http.html#http_class_http_server\n */\n\n/**\n * A handler function for action requests (button presses, menu selections, and dialog submissions).\n *\n * @name module:adapter~SlackMessageAdapter~ActionHandler\n * @function\n * @param {Object} payload - an object describing the\n * [button press](https://api.slack.com/docs/message-buttons#responding_to_message_actions),\n * [menu selection](https://api.slack.com/docs/message-menus#request_url_response), or\n * [dialog submission](https://api.slack.com/dialogs#evaluating_submission_responses).\n * @param {module:adapter~SlackMessageAdapter~ActionHandler~Respond} respond - When the action is a\n * button press or menu selection, this function is used to update the message where the action\n * occured or create new messages in the same conversation. When the action is a dialog submission,\n * this function is used to create new messages in the conversation where the dialog was triggered.\n * @returns {Object} When the action is a button press or a menu selection, this object is a\n * replacement\n * [message](https://api.slack.com/docs/interactive-message-field-guide#top-level_message_fields)\n * for the message in which the action occurred. It may also be a Promise for a message, and if so\n * and the Promise takes longer than the `syncResponseTimeout` to complete, the message is sent over\n * the `response_url`. The message may also be a new message in the same conversation by setting\n * `replace_original: false`. When the action is a dialog submission, this object is a list of\n * [validation errors](https://api.slack.com/dialogs#input_validation). It may also be a Promise for\n * a list of validation errors, and if so and the Promise takes longer than the\n * `syncReponseTimeout` to complete, Slack will disply an error to the user. If there is no return\n * value, then button presses and menu selections do not update the message and dialog submissions\n * will validate and dismiss.\n */\n\n/**\n * A function used to send message updates after an action is handled. This function can be used\n * up to 5 times in 30 minutes.\n *\n * @name module:adapter~SlackMessageAdapter~ActionHandler~Respond\n * @function\n * @param {Object} message - a\n * [message](https://api.slack.com/docs/interactive-message-field-guide#top-level_message_fields).\n * Dialog submissions do not allow `resplace_original: false` on this message.\n * @returns {Promise} there's no contract or interface for the resolution value, but this Promise\n * will resolve when the HTTP response from the `response_url` request is complete and reject when\n * there is an error.\n */\n\n/**\n * A handler function for menu options requests.\n *\n * @name module:adapter~SlackMessageAdapter~OptionsHandler\n * @function\n * @param {Object} payload - an object describing\n * [the state of the menu](https://api.slack.com/docs/message-menus#options_load_url)\n * @returns {Object} an\n * [options list](https://api.slack.com/docs/interactive-message-field-guide#option_fields) or\n * [option groups list](https://api.slack.com/docs/interactive-message-field-guide#option_groups).\n * When the menu is within an interactive message, (`within: 'interactive_message'`) the option\n * keys are `text` and `value`. When the menu is within a dialog (`within: 'dialog'`) the option\n * keys are `label` and `value`. This function may also return a Promise either of these values.\n * If a Promise is returned and it does not complete within 3 seconds, Slack will display an error\n * to the user. If there is no return value, then the user is shown an empty list of options.\n */\n"]}